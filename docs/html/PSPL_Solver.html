<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PSPL_Solver &mdash; BAGLE 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Prior Generators" href="Prior_Generator.html" />
    <link rel="prev" title="Model Fitter" href="model_fitter.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> BAGLE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Overview of bagle.model</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html#developers">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ModelClass.html">Instantiable Model Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="PSPL.html">POINT SOURCE POINT LENS (PSPL) CLASSES</a></li>
<li class="toctree-l1"><a class="reference internal" href="PSBL.html">POINT SOURCE BINARY LENS (PSBL) CLASSES</a></li>
<li class="toctree-l1"><a class="reference internal" href="BSPL.html">BINARY SOURCE POINT LENS (BSPL) CLASSES</a></li>
<li class="toctree-l1"><a class="reference internal" href="FSPL.html">FSPL(Finite-Source Point Lens) Models - NOT DONE YET… place holders</a></li>
<li class="toctree-l1"><a class="reference internal" href="Gen_Use.html">GENERAL USE AND SHARED FUNCTIONS</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="model_fitter.html">Model Fitter</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">PSPL_Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="Prior_Generator.html">Prior Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="Gen_Use_model_fitter.html">GENERAL USE AND SHARED FUNCTIONS</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BAGLE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="model_fitter.html">Model Fitter</a> &raquo;</li>
      <li>PSPL_Solver</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/PSPL_Solver.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pspl-solver">
<h1>PSPL_Solver<a class="headerlink" href="#pspl-solver" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">model_fitter.</span></span><span class="sig-name descname"><span class="pre">PSPL_Solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_additional_param_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_error_on_photometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiply_error_on_photometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_phot_optional_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ast_optional_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrapped_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">importance_nested_sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multimodal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">const_efficiency_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_live_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evidence_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_efficiency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter_before_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">null_log_evidence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+90</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+90</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputfiles_basename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'chains/1-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_MPI</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></p>
<p>A PyMultiNest solver to find the optimal PSPL parameters, given data and
a microlensing model from model.py.
DESPITE THE NAME YOU CAN ALSO USE IT TO FIT PSBL!</p>
<p class="rubric">Examples</p>
<p>Assuming that a data dictionary has been instantiated with the above keys,
and that a model has been loaded in from model.py, PSPL_Solver can be run
with the following commands:
.. code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fitter</span> <span class="o">=</span> <span class="n">PSPL_Solver</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                     <span class="n">PSPL_PhotAstrom_Par_Param1</span><span class="p">,</span>
                     <span class="n">add_error_on_photometry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">custom_additional_param_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dS&#39;</span><span class="p">,</span> <span class="s1">&#39;tE&#39;</span><span class="p">],</span>
                     <span class="n">outputfiles_basename</span><span class="o">=</span><span class="s1">&#39;./model_output/test_&#39;</span><span class="p">)</span>
<span class="n">fitter</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">dictionary</span></dt><dd><p>Observational data used to fit a microlensing model. What the data must
contain depends on what type of microlensing model you are solving for.</p>
<p>The data dictionary must always photometry information of at least one
filter. This data must contain the times, magnitudes, and magnitude
errors of the observations. The keys to these arrays are:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>t_phot1</cite> (MJD)</p></li>
<li><p><cite>mag1</cite> (magnitudes)</p></li>
<li><p><cite>mag_err1</cite> (magnitudes)</p></li>
</ul>
</div></blockquote>
<p>PSPL_Solver supports multiple photometric filters. For each
additional filter, increments the extension of the above keys by one.
For example, a second filter would be:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>t_phot2</cite> (MJD)</p></li>
<li><p><cite>mag2</cite> (magnitudes)</p></li>
<li><p><cite>mag_err2</cite> (magnitudes)</p></li>
</ul>
</div></blockquote>
<p>PSPL_Solver supports solving microlensing models that calculate with
parallax. These models must be accompanied with data that contains the
right ascenscion and declination of the target. These keys are:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>raL</cite> (decimal degrees)</p></li>
<li><p><cite>decL</cite> (decimal degrees)</p></li>
</ul>
</div></blockquote>
<p>PSPL_Solver supports solving microlensing models that fit astrometry.
These models must be accompanied with data that contains astrometric
observations in the following keys:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>t_ast</cite> (MJD)</p></li>
<li><p><cite>xpos</cite> (arcsec along East-West increasing to the East)</p></li>
<li><p><cite>ypos</cite> (arcsec along the North-South increasing to the North)</p></li>
<li><p><cite>xpos_err</cite> (arcsec)</p></li>
<li><p><cite>ypos_err</cite> (arcsec)</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>model_class</strong></dt><dd><p>PSPL_Solver must be provided with the microlensing model that you are
trying to fit to your data. These models are written out in model.py,
along with extensive documentation as to their content and
construction in the file’s docstring. The model can support either</p>
<ol class="arabic simple">
<li><p>photometric data or photometric and astrometric data,</p></li>
<li><p>parallax or no parallax, and</p></li>
<li><p>different parameterizations of the model.</p></li>
</ol>
<p>For example, a model with accepts both astrometric and photometric
data, uses parallax, and uses a parameterization that includes the
distance to the source and the lens is: <cite>PSPL_PhotAstrom_Par_Param1</cite>.</p>
</dd>
<dt><strong>custom_additional_param_names</strong><span class="classifier">list, optional</span></dt><dd><p>If provided, the fitter will override the default
<cite>additional_param_names</cite> of the model_class. These are the parameters,
besides those that are being fitted for, that are written out to disk
for posterior plotting after the fit has completed. To see the default
additional_param_names run:</p>
<blockquote>
<div><p><cite>print(model_class.additional _param_names)</cite></p>
</div></blockquote>
</dd>
<dt><strong>add_error_on_photometry</strong><span class="classifier">boolean, optional</span></dt><dd><p>If set to True, the fitter will fit for an additive error to the
photometric magnitudes in the fitting process. This error will have
the name <cite>add_errN</cite>, with an <cite>N</cite> equal to the filter number.</p>
</dd>
<dt><strong>multiply_error_on_photometry</strong><span class="classifier">boolean, optional</span></dt><dd><p>If set to True, the fitter will fit for a multiplicative error to the
photometric magnitudes in the fitting process. This error will have
the name <cite>mult_errN</cite>, with an <cite>N</cite> equal to the filter number.</p>
</dd>
<dt><strong>All other parameters</strong></dt><dd><p>See pymultinest.run() for a description of all other parameters.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.LogLikelihood" title="model_fitter.PSPL_Solver.LogLikelihood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LogLikelihood</span></code></a>(cube[, ndim, n_params])</p></td>
<td><p>This is just a wrapper because PyMultinest requires passing in the ndim and nparams.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Prior</span></code>(cube[, ndim, nparams])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.Prior_from_post" title="model_fitter.PSPL_Solver.Prior_from_post"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Prior_from_post</span></code></a>(cube[, ndim, nparams])</p></td>
<td><p>Get the bin midpoints</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.calc_best_fit" title="model_fitter.PSPL_Solver.calc_best_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_best_fit</span></code></a>(tab, smy[, s_idx, def_best])</p></td>
<td><p>Returns best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.calc_chi2" title="model_fitter.PSPL_Solver.calc_chi2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_chi2</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.calc_chi2_manual" title="model_fitter.PSPL_Solver.calc_chi2_manual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_chi2_manual</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.get_best_fit" title="model_fitter.PSPL_Solver.get_best_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit</span></code></a>([def_best])</p></td>
<td><p>Returns best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.get_best_fit_model" title="model_fitter.PSPL_Solver.get_best_fit_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit_model</span></code></a>([def_best])</p></td>
<td><p>Identify best-fit model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.get_best_fit_modes" title="model_fitter.PSPL_Solver.get_best_fit_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit_modes</span></code></a>([def_best])</p></td>
<td><p>Returns a list of best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.load_mnest_modes" title="model_fitter.PSPL_Solver.load_mnest_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_modes</span></code></a>([remake_fits])</p></td>
<td><p>Load up the separate modes results into an astropy table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.load_mnest_modes_results_for_dynesty" title="model_fitter.PSPL_Solver.load_mnest_modes_results_for_dynesty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_modes_results_for_dynesty</span></code></a>([...])</p></td>
<td><p>Make a Dynesty-style results object that can  be used in the nicer plotting codes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.load_mnest_results" title="model_fitter.PSPL_Solver.load_mnest_results"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_results</span></code></a>([remake_fits])</p></td>
<td><p>Load up the MultiNest results into an astropy table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.load_mnest_results_for_dynesty" title="model_fitter.PSPL_Solver.load_mnest_results_for_dynesty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_results_for_dynesty</span></code></a>([remake_fits])</p></td>
<td><p>Make a Dynesty-style results object that can be used in the nicer plotting codes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.load_mnest_summary" title="model_fitter.PSPL_Solver.load_mnest_summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_summary</span></code></a>([remake_fits])</p></td>
<td><p>Load up the MultiNest results into an astropy table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.log_likely" title="model_fitter.PSPL_Solver.log_likely"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log_likely</span></code></a>(cube[, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.make_default_priors" title="model_fitter.PSPL_Solver.make_default_priors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_default_priors</span></code></a>()</p></td>
<td><p>Setup our prior distributions (i.e.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.plot_dynesty_style" title="model_fitter.PSPL_Solver.plot_dynesty_style"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_dynesty_style</span></code></a>([sim_vals, fit_vals, ...])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.plot_model_and_data" title="model_fitter.PSPL_Solver.plot_model_and_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_model_and_data</span></code></a>(model[, input_model, ...])</p></td>
<td><p>Make and save the model and data plots.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.plot_model_and_data_modes" title="model_fitter.PSPL_Solver.plot_model_and_data_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_model_and_data_modes</span></code></a>([def_best])</p></td>
<td><p>Plots photometry data, along with n random draws from the posterior.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.print_likelihood" title="model_fitter.PSPL_Solver.print_likelihood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_likelihood</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.sample_post" title="model_fitter.PSPL_Solver.sample_post"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_post</span></code></a>(binmids, cdf, bininds)</p></td>
<td><p>Randomly sample from a multinest posterior distribution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.separate_modes" title="model_fitter.PSPL_Solver.separate_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">separate_modes</span></code></a>()</p></td>
<td><p>Reads in the fits for the different modes (post_separate.dat) and splits it into a .dat file per mode.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.solve" title="model_fitter.PSPL_Solver.solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code></a>()</p></td>
<td><p>Run a MultiNest fit to find the optimal parameters (and their posteriors) given the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver.write_params_yaml" title="model_fitter.PSPL_Solver.write_params_yaml"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_params_yaml</span></code></a>()</p></td>
<td><p>Write a YAML file that contains the parameters to re-initialize this object, if desired.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Prior_copy</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>callback_plotter</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>check_data</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>dyn_log_likely</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>dyn_prior</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_best_fit_modes_model</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_model</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_modified_mag_err</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>log_likely_astrometry</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>log_likely_photometry</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>setup_params</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>summarize_results</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>summarize_results_modes</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>write_summary_maxL</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.make_default_priors">
<span class="sig-name descname"><span class="pre">make_default_priors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.make_default_priors" title="Permalink to this definition"></a></dt>
<dd><p>Setup our prior distributions (i.e. random samplers). We will
draw from these in the Prior() function. We set them up in advance
because they depend on properties of the data. Also,
they can be over-written by custom priors as desired.</p>
<p>To make your own custom priors, use the make_gen() functions
with different limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.Prior_from_post">
<span class="sig-name descname"><span class="pre">Prior_from_post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nparams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.Prior_from_post" title="Permalink to this definition"></a></dt>
<dd><p>Get the bin midpoints</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.sample_post">
<span class="sig-name descname"><span class="pre">sample_post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binmids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bininds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.sample_post" title="Permalink to this definition"></a></dt>
<dd><p>Randomly sample from a multinest posterior distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Nparams:</strong></dt><dd><p>number of parameters</p>
</dd>
<dt><strong>Nbins:</strong></dt><dd><p>number of histogram bins per dimension</p>
</dd>
<dt><strong>Nnzero:</strong></dt><dd><p>number of histogram bins with non-zero probability</p>
</dd>
<dt><strong>binmids</strong><span class="classifier">list of length N, each list entry is an array of shape (M, )</span></dt><dd><p>The centers of the bins for each parameter</p>
</dd>
<dt><strong>cdf</strong><span class="classifier">(Nnzero, ) array</span></dt><dd><p>CDF of the distribution. Only the non-zero probability entries.</p>
</dd>
<dt><strong>bininds</strong><span class="classifier">(Nnzero, Nparams) array</span></dt><dd><p>Histogram indices of the non-zero probability entries.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.LogLikelihood">
<span class="sig-name descname"><span class="pre">LogLikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.LogLikelihood" title="Permalink to this definition"></a></dt>
<dd><p>This is just a wrapper because PyMultinest requires passing in
the ndim and nparams.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.log_likely">
<span class="sig-name descname"><span class="pre">log_likely</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.log_likely" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cube</strong><span class="classifier">list or dict</span></dt><dd><p>The dictionary or cube of the model parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.write_params_yaml">
<span class="sig-name descname"><span class="pre">write_params_yaml</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.write_params_yaml" title="Permalink to this definition"></a></dt>
<dd><p>Write a YAML file that contains the parameters to re-initialize
this object, if desired.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.solve" title="Permalink to this definition"></a></dt>
<dd><p>Run a MultiNest fit to find the optimal parameters (and their
posteriors) given the data.</p>
<p>Note we will ALWAYS tell multinest to be verbose.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.separate_modes">
<span class="sig-name descname"><span class="pre">separate_modes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.separate_modes" title="Permalink to this definition"></a></dt>
<dd><p>Reads in the fits for the different modes (post_separate.dat)
and splits it into a .dat file per mode.</p>
<p>Is there a more intelligent way to deal with all the indices???
Write better later, but it seems to work for now…</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.calc_best_fit">
<span class="sig-name descname"><span class="pre">calc_best_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.calc_best_fit" title="Permalink to this definition"></a></dt>
<dd><p>Returns best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If best-fit is median, then also return +/- 1 sigma
uncertainties.</p>
<p>If best-fit is MAP, then also need to indicate which row of
summary table to use. Default is <cite>s_idx = 0</cite> (global solution).
<cite>s_idx = 1, 2, … , n</cite> for the n different modes.</p>
<p><cite>tab = self.load_mnest_results()</cite>
<cite>smy = self.load_mnest_summary()</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.get_best_fit">
<span class="sig-name descname"><span class="pre">get_best_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.get_best_fit" title="Permalink to this definition"></a></dt>
<dd><p>Returns best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If def_best is median, then also return +/- 1 sigma
uncertainties.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Either a dicitonary or a tuple of length=2 holding</dt><dd></dd>
<dt>two dictionaries, one for values and one for uncertainty ranges.</dt><dd></dd>
<dt>See calc_best_fit() for details.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.get_best_fit_modes">
<span class="sig-name descname"><span class="pre">get_best_fit_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.get_best_fit_modes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If def_best is median, then also return +/- 1 sigma
uncertainties.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Either a list of dicitonaries or a list where each entry is</dt><dd></dd>
<dt>a tuple of length=2 holding two dictionaries, one for values</dt><dd></dd>
<dt>and one for uncertainty ranges.</dt><dd></dd>
<dt>See calc_best_fit() for details.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.get_best_fit_model">
<span class="sig-name descname"><span class="pre">get_best_fit_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.get_best_fit_model" title="Permalink to this definition"></a></dt>
<dd><p>Identify best-fit model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>def_best</strong><span class="classifier">str</span></dt><dd><p>Choices are ‘map’ (maximum a posteriori), ‘median’, or
‘maxl’ (maximum likelihood)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.load_mnest_results">
<span class="sig-name descname"><span class="pre">load_mnest_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.load_mnest_results" title="Permalink to this definition"></a></dt>
<dd><p>Load up the MultiNest results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.load_mnest_summary">
<span class="sig-name descname"><span class="pre">load_mnest_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.load_mnest_summary" title="Permalink to this definition"></a></dt>
<dd><p>Load up the MultiNest results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.load_mnest_modes">
<span class="sig-name descname"><span class="pre">load_mnest_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.load_mnest_modes" title="Permalink to this definition"></a></dt>
<dd><p>Load up the separate modes results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.load_mnest_results_for_dynesty">
<span class="sig-name descname"><span class="pre">load_mnest_results_for_dynesty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.load_mnest_results_for_dynesty" title="Permalink to this definition"></a></dt>
<dd><p>Make a Dynesty-style results object that can
be used in the nicer plotting codes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.load_mnest_modes_results_for_dynesty">
<span class="sig-name descname"><span class="pre">load_mnest_modes_results_for_dynesty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.load_mnest_modes_results_for_dynesty" title="Permalink to this definition"></a></dt>
<dd><p>Make a Dynesty-style results object that can 
be used in the nicer plotting codes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.plot_dynesty_style">
<span class="sig-name descname"><span class="pre">plot_dynesty_style</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_vals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_vals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cornerplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kde</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.plot_dynesty_style" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sim_vals</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of simulated input or comparison values to 
overplot on posteriors.</p>
</dd>
<dt><strong>fit_vals</strong><span class="classifier">str</span></dt><dd><p>Choices are ‘map’ (maximum a posteriori), ‘mean’, or
‘maxl’ (maximum likelihood)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.plot_model_and_data">
<span class="sig-name descname"><span class="pre">plot_model_and_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mnest_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomy_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_traces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.plot_model_and_data" title="Permalink to this definition"></a></dt>
<dd><p>Make and save the model and data plots.</p>
<p>zoomx, xoomy, zoomy_res : list the same length as <cite>self.n_phot_sets</cite>
Each entry of the list is a list <cite>[a, b]</cite> cooresponding to the plot limits</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.plot_model_and_data_modes">
<span class="sig-name descname"><span class="pre">plot_model_and_data_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.plot_model_and_data_modes" title="Permalink to this definition"></a></dt>
<dd><p>Plots photometry data, along with n random draws from the posterior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.print_likelihood">
<span class="sig-name descname"><span class="pre">print_likelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.print_likelihood" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_params</strong><span class="classifier">str or dict, optional</span></dt><dd><dl class="simple">
<dt>model_params = ‘best’ will load up the best solution and calculate</dt><dd><p>the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.calc_chi2">
<span class="sig-name descname"><span class="pre">calc_chi2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.calc_chi2" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">str or dict, optional</span></dt><dd><p>model_params = ‘best’ will load up the best solution and calculate
the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver.calc_chi2_manual">
<span class="sig-name descname"><span class="pre">calc_chi2_manual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver.calc_chi2_manual" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">str or dict, optional</span></dt><dd><p>model_params = ‘best’ will load up the best solution and calculate
the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">model_fitter.</span></span><span class="sig-name descname"><span class="pre">PSPL_Solver_weighted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_additional_param_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_error_on_photometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiply_error_on_photometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_phot_optional_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ast_optional_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrapped_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">importance_nested_sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multimodal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">const_efficiency_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_live_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evidence_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_efficiency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter_before_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">null_log_evidence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+90</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+90</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputfiles_basename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'chains/1-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_MPI</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'phot_ast_equal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#model_fitter.PSPL_Solver" title="model_fitter.PSPL_Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSPL_Solver</span></code></a></p>
<p>Soliver where the likelihood function has each data
set weigthed equally (i.e. not the natural weighting by
the number of points; but rather each contributes
1/n_k where n is the number of data points and k is the data set.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.LogLikelihood" title="model_fitter.PSPL_Solver_weighted.LogLikelihood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LogLikelihood</span></code></a>(cube[, ndim, n_params])</p></td>
<td><p>This is just a wrapper because PyMultinest requires passing in the ndim and nparams.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Prior</span></code>(cube[, ndim, nparams])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.Prior_from_post" title="model_fitter.PSPL_Solver_weighted.Prior_from_post"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Prior_from_post</span></code></a>(cube[, ndim, nparams])</p></td>
<td><p>Get the bin midpoints</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.calc_best_fit" title="model_fitter.PSPL_Solver_weighted.calc_best_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_best_fit</span></code></a>(tab, smy[, s_idx, def_best])</p></td>
<td><p>Returns best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.calc_chi2" title="model_fitter.PSPL_Solver_weighted.calc_chi2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_chi2</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.calc_chi2_manual" title="model_fitter.PSPL_Solver_weighted.calc_chi2_manual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_chi2_manual</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.calc_weights" title="model_fitter.PSPL_Solver_weighted.calc_weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_weights</span></code></a>(weights)</p></td>
<td><p>order of weight_arr is  <a href="#id1"><span class="problematic" id="id2">`</span></a>[phot_1, phot_2, .</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.get_best_fit" title="model_fitter.PSPL_Solver_weighted.get_best_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit</span></code></a>([def_best])</p></td>
<td><p>Returns best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.get_best_fit_model" title="model_fitter.PSPL_Solver_weighted.get_best_fit_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit_model</span></code></a>([def_best])</p></td>
<td><p>Identify best-fit model</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.get_best_fit_modes" title="model_fitter.PSPL_Solver_weighted.get_best_fit_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit_modes</span></code></a>([def_best])</p></td>
<td><p>Returns a list of best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.load_mnest_modes" title="model_fitter.PSPL_Solver_weighted.load_mnest_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_modes</span></code></a>([remake_fits])</p></td>
<td><p>Load up the separate modes results into an astropy table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.load_mnest_modes_results_for_dynesty" title="model_fitter.PSPL_Solver_weighted.load_mnest_modes_results_for_dynesty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_modes_results_for_dynesty</span></code></a>([...])</p></td>
<td><p>Make a Dynesty-style results object that can  be used in the nicer plotting codes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.load_mnest_results" title="model_fitter.PSPL_Solver_weighted.load_mnest_results"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_results</span></code></a>([remake_fits])</p></td>
<td><p>Load up the MultiNest results into an astropy table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.load_mnest_results_for_dynesty" title="model_fitter.PSPL_Solver_weighted.load_mnest_results_for_dynesty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_results_for_dynesty</span></code></a>([remake_fits])</p></td>
<td><p>Make a Dynesty-style results object that can be used in the nicer plotting codes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.load_mnest_summary" title="model_fitter.PSPL_Solver_weighted.load_mnest_summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_summary</span></code></a>([remake_fits])</p></td>
<td><p>Load up the MultiNest results into an astropy table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.log_likely" title="model_fitter.PSPL_Solver_weighted.log_likely"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log_likely</span></code></a>(cube[, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.make_default_priors" title="model_fitter.PSPL_Solver_weighted.make_default_priors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_default_priors</span></code></a>()</p></td>
<td><p>Setup our prior distributions (i.e.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.plot_dynesty_style" title="model_fitter.PSPL_Solver_weighted.plot_dynesty_style"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_dynesty_style</span></code></a>([sim_vals, fit_vals, ...])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.plot_model_and_data" title="model_fitter.PSPL_Solver_weighted.plot_model_and_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_model_and_data</span></code></a>(model[, input_model, ...])</p></td>
<td><p>Make and save the model and data plots.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.plot_model_and_data_modes" title="model_fitter.PSPL_Solver_weighted.plot_model_and_data_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_model_and_data_modes</span></code></a>([def_best])</p></td>
<td><p>Plots photometry data, along with n random draws from the posterior.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.print_likelihood" title="model_fitter.PSPL_Solver_weighted.print_likelihood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_likelihood</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.sample_post" title="model_fitter.PSPL_Solver_weighted.sample_post"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_post</span></code></a>(binmids, cdf, bininds)</p></td>
<td><p>Randomly sample from a multinest posterior distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.separate_modes" title="model_fitter.PSPL_Solver_weighted.separate_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">separate_modes</span></code></a>()</p></td>
<td><p>Reads in the fits for the different modes (post_separate.dat) and splits it into a .dat file per mode.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.solve" title="model_fitter.PSPL_Solver_weighted.solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code></a>()</p></td>
<td><p>Run a MultiNest fit to find the optimal parameters (and their posteriors) given the data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_weighted.write_params_yaml" title="model_fitter.PSPL_Solver_weighted.write_params_yaml"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_params_yaml</span></code></a>()</p></td>
<td><p>Write a YAML file that contains the parameters to re-initialize this object, if desired.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Prior_copy</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>callback_plotter</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>check_data</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>dyn_log_likely</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>dyn_prior</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_best_fit_modes_model</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_model</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_modified_mag_err</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>log_likely_astrometry</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>log_likely_photometry</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>setup_params</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>summarize_results</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>summarize_results_modes</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>write_summary_maxL</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.calc_weights">
<span class="sig-name descname"><span class="pre">calc_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.calc_weights" title="Permalink to this definition"></a></dt>
<dd><p>order of weight_arr is 
<cite>[phot_1, phot_2, … phot_n, ast_1, ast_2, … ast_n]</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.LogLikelihood">
<span class="sig-name descname"><span class="pre">LogLikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.LogLikelihood" title="Permalink to this definition"></a></dt>
<dd><p>This is just a wrapper because PyMultinest requires passing in
the ndim and nparams.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.Prior_from_post">
<span class="sig-name descname"><span class="pre">Prior_from_post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nparams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.Prior_from_post" title="Permalink to this definition"></a></dt>
<dd><p>Get the bin midpoints</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.calc_best_fit">
<span class="sig-name descname"><span class="pre">calc_best_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.calc_best_fit" title="Permalink to this definition"></a></dt>
<dd><p>Returns best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If best-fit is median, then also return +/- 1 sigma
uncertainties.</p>
<p>If best-fit is MAP, then also need to indicate which row of
summary table to use. Default is <cite>s_idx = 0</cite> (global solution).
<cite>s_idx = 1, 2, … , n</cite> for the n different modes.</p>
<p><cite>tab = self.load_mnest_results()</cite>
<cite>smy = self.load_mnest_summary()</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.calc_chi2">
<span class="sig-name descname"><span class="pre">calc_chi2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.calc_chi2" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">str or dict, optional</span></dt><dd><p>model_params = ‘best’ will load up the best solution and calculate
the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.calc_chi2_manual">
<span class="sig-name descname"><span class="pre">calc_chi2_manual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.calc_chi2_manual" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">str or dict, optional</span></dt><dd><p>model_params = ‘best’ will load up the best solution and calculate
the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.get_best_fit">
<span class="sig-name descname"><span class="pre">get_best_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.get_best_fit" title="Permalink to this definition"></a></dt>
<dd><p>Returns best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If def_best is median, then also return +/- 1 sigma
uncertainties.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Either a dicitonary or a tuple of length=2 holding</dt><dd></dd>
<dt>two dictionaries, one for values and one for uncertainty ranges.</dt><dd></dd>
<dt>See calc_best_fit() for details.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.get_best_fit_model">
<span class="sig-name descname"><span class="pre">get_best_fit_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.get_best_fit_model" title="Permalink to this definition"></a></dt>
<dd><p>Identify best-fit model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>def_best</strong><span class="classifier">str</span></dt><dd><p>Choices are ‘map’ (maximum a posteriori), ‘median’, or
‘maxl’ (maximum likelihood)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.get_best_fit_modes">
<span class="sig-name descname"><span class="pre">get_best_fit_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.get_best_fit_modes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If def_best is median, then also return +/- 1 sigma
uncertainties.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Either a list of dicitonaries or a list where each entry is</dt><dd></dd>
<dt>a tuple of length=2 holding two dictionaries, one for values</dt><dd></dd>
<dt>and one for uncertainty ranges.</dt><dd></dd>
<dt>See calc_best_fit() for details.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.load_mnest_modes">
<span class="sig-name descname"><span class="pre">load_mnest_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.load_mnest_modes" title="Permalink to this definition"></a></dt>
<dd><p>Load up the separate modes results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.load_mnest_modes_results_for_dynesty">
<span class="sig-name descname"><span class="pre">load_mnest_modes_results_for_dynesty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.load_mnest_modes_results_for_dynesty" title="Permalink to this definition"></a></dt>
<dd><p>Make a Dynesty-style results object that can 
be used in the nicer plotting codes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.load_mnest_results">
<span class="sig-name descname"><span class="pre">load_mnest_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.load_mnest_results" title="Permalink to this definition"></a></dt>
<dd><p>Load up the MultiNest results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.load_mnest_results_for_dynesty">
<span class="sig-name descname"><span class="pre">load_mnest_results_for_dynesty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.load_mnest_results_for_dynesty" title="Permalink to this definition"></a></dt>
<dd><p>Make a Dynesty-style results object that can
be used in the nicer plotting codes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.load_mnest_summary">
<span class="sig-name descname"><span class="pre">load_mnest_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.load_mnest_summary" title="Permalink to this definition"></a></dt>
<dd><p>Load up the MultiNest results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.log_likely">
<span class="sig-name descname"><span class="pre">log_likely</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.log_likely" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cube</strong><span class="classifier">list or dict</span></dt><dd><p>The dictionary or cube of the model parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.make_default_priors">
<span class="sig-name descname"><span class="pre">make_default_priors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.make_default_priors" title="Permalink to this definition"></a></dt>
<dd><p>Setup our prior distributions (i.e. random samplers). We will
draw from these in the Prior() function. We set them up in advance
because they depend on properties of the data. Also,
they can be over-written by custom priors as desired.</p>
<p>To make your own custom priors, use the make_gen() functions
with different limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.plot_dynesty_style">
<span class="sig-name descname"><span class="pre">plot_dynesty_style</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_vals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_vals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cornerplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kde</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.plot_dynesty_style" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sim_vals</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of simulated input or comparison values to 
overplot on posteriors.</p>
</dd>
<dt><strong>fit_vals</strong><span class="classifier">str</span></dt><dd><p>Choices are ‘map’ (maximum a posteriori), ‘mean’, or
‘maxl’ (maximum likelihood)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.plot_model_and_data">
<span class="sig-name descname"><span class="pre">plot_model_and_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mnest_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomy_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_traces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.plot_model_and_data" title="Permalink to this definition"></a></dt>
<dd><p>Make and save the model and data plots.</p>
<p>zoomx, xoomy, zoomy_res : list the same length as <cite>self.n_phot_sets</cite>
Each entry of the list is a list <cite>[a, b]</cite> cooresponding to the plot limits</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.plot_model_and_data_modes">
<span class="sig-name descname"><span class="pre">plot_model_and_data_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.plot_model_and_data_modes" title="Permalink to this definition"></a></dt>
<dd><p>Plots photometry data, along with n random draws from the posterior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.print_likelihood">
<span class="sig-name descname"><span class="pre">print_likelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.print_likelihood" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_params</strong><span class="classifier">str or dict, optional</span></dt><dd><dl class="simple">
<dt>model_params = ‘best’ will load up the best solution and calculate</dt><dd><p>the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.sample_post">
<span class="sig-name descname"><span class="pre">sample_post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binmids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bininds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.sample_post" title="Permalink to this definition"></a></dt>
<dd><p>Randomly sample from a multinest posterior distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Nparams:</strong></dt><dd><p>number of parameters</p>
</dd>
<dt><strong>Nbins:</strong></dt><dd><p>number of histogram bins per dimension</p>
</dd>
<dt><strong>Nnzero:</strong></dt><dd><p>number of histogram bins with non-zero probability</p>
</dd>
<dt><strong>binmids</strong><span class="classifier">list of length N, each list entry is an array of shape (M, )</span></dt><dd><p>The centers of the bins for each parameter</p>
</dd>
<dt><strong>cdf</strong><span class="classifier">(Nnzero, ) array</span></dt><dd><p>CDF of the distribution. Only the non-zero probability entries.</p>
</dd>
<dt><strong>bininds</strong><span class="classifier">(Nnzero, Nparams) array</span></dt><dd><p>Histogram indices of the non-zero probability entries.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.separate_modes">
<span class="sig-name descname"><span class="pre">separate_modes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.separate_modes" title="Permalink to this definition"></a></dt>
<dd><p>Reads in the fits for the different modes (post_separate.dat)
and splits it into a .dat file per mode.</p>
<p>Is there a more intelligent way to deal with all the indices???
Write better later, but it seems to work for now…</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.solve" title="Permalink to this definition"></a></dt>
<dd><p>Run a MultiNest fit to find the optimal parameters (and their
posteriors) given the data.</p>
<p>Note we will ALWAYS tell multinest to be verbose.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_weighted.write_params_yaml">
<span class="sig-name descname"><span class="pre">write_params_yaml</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_weighted.write_params_yaml" title="Permalink to this definition"></a></dt>
<dd><p>Write a YAML file that contains the parameters to re-initialize
this object, if desired.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">model_fitter.</span></span><span class="sig-name descname"><span class="pre">PSPL_Solver_Hobson_Weighted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_additional_param_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_error_on_photometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiply_error_on_photometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_phot_optional_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ast_optional_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrapped_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">importance_nested_sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multimodal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">const_efficiency_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_live_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evidence_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_efficiency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter_before_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">null_log_evidence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+90</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+90</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputfiles_basename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'chains/1-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1e+100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_MPI</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#model_fitter.PSPL_Solver" title="model_fitter.PSPL_Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSPL_Solver</span></code></a></p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.LogLikelihood" title="model_fitter.PSPL_Solver_Hobson_Weighted.LogLikelihood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LogLikelihood</span></code></a>(cube[, ndim, n_params])</p></td>
<td><p>This is just a wrapper because PyMultinest requires passing in the ndim and nparams.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Prior</span></code>(cube[, ndim, nparams])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.Prior_from_post" title="model_fitter.PSPL_Solver_Hobson_Weighted.Prior_from_post"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Prior_from_post</span></code></a>(cube[, ndim, nparams])</p></td>
<td><p>Get the bin midpoints</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.calc_best_fit" title="model_fitter.PSPL_Solver_Hobson_Weighted.calc_best_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_best_fit</span></code></a>(tab, smy[, s_idx, def_best])</p></td>
<td><p>Returns best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.calc_chi2" title="model_fitter.PSPL_Solver_Hobson_Weighted.calc_chi2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_chi2</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.calc_chi2_manual" title="model_fitter.PSPL_Solver_Hobson_Weighted.calc_chi2_manual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_chi2_manual</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit" title="model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit</span></code></a>([def_best])</p></td>
<td><p>Returns best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit_model" title="model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit_model</span></code></a>([def_best])</p></td>
<td><p>Identify best-fit model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit_modes" title="model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_best_fit_modes</span></code></a>([def_best])</p></td>
<td><p>Returns a list of best-fit parameters, where best-fit can be median, maxl, or MAP.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.get_hobson_effective_weights" title="model_fitter.PSPL_Solver_Hobson_Weighted.get_hobson_effective_weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_hobson_effective_weights</span></code></a>(cube)</p></td>
<td><p>Return the effective weights, alpha_k, for each data set.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.hobson_weight_log_likely" title="model_fitter.PSPL_Solver_Hobson_Weighted.hobson_weight_log_likely"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hobson_weight_log_likely</span></code></a>(ln_prob_dk_giv_ak_1)</p></td>
<td><p>Implement a data-set-specific weighting scheme by using a hyperparameter, alpha_k, for the kth data set as  described in Hobson et al. 2002.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_modes" title="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_modes</span></code></a>([remake_fits])</p></td>
<td><p>Load up the separate modes results into an astropy table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_modes_results_for_dynesty" title="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_modes_results_for_dynesty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_modes_results_for_dynesty</span></code></a>([...])</p></td>
<td><p>Make a Dynesty-style results object that can  be used in the nicer plotting codes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_results" title="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_results"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_results</span></code></a>([remake_fits])</p></td>
<td><p>Load up the MultiNest results into an astropy table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_results_for_dynesty" title="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_results_for_dynesty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_results_for_dynesty</span></code></a>([remake_fits])</p></td>
<td><p>Make a Dynesty-style results object that can be used in the nicer plotting codes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_summary" title="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_mnest_summary</span></code></a>([remake_fits])</p></td>
<td><p>Load up the MultiNest results into an astropy table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.log_likely" title="model_fitter.PSPL_Solver_Hobson_Weighted.log_likely"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log_likely</span></code></a>(cube[, verbose])</p></td>
<td><p>Compute a log-likelihood where there is a hyperparameter, alpha_k, that controls the weighting between each data k set.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.make_default_priors" title="model_fitter.PSPL_Solver_Hobson_Weighted.make_default_priors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_default_priors</span></code></a>()</p></td>
<td><p>Setup our prior distributions (i.e.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.plot_dynesty_style" title="model_fitter.PSPL_Solver_Hobson_Weighted.plot_dynesty_style"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_dynesty_style</span></code></a>([sim_vals, fit_vals, ...])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.plot_model_and_data" title="model_fitter.PSPL_Solver_Hobson_Weighted.plot_model_and_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_model_and_data</span></code></a>(model[, input_model, ...])</p></td>
<td><p>Make and save the model and data plots.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.plot_model_and_data_modes" title="model_fitter.PSPL_Solver_Hobson_Weighted.plot_model_and_data_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_model_and_data_modes</span></code></a>([def_best])</p></td>
<td><p>Plots photometry data, along with n random draws from the posterior.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.print_likelihood" title="model_fitter.PSPL_Solver_Hobson_Weighted.print_likelihood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_likelihood</span></code></a>([params, verbose])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.sample_post" title="model_fitter.PSPL_Solver_Hobson_Weighted.sample_post"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_post</span></code></a>(binmids, cdf, bininds)</p></td>
<td><p>Randomly sample from a multinest posterior distribution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.separate_modes" title="model_fitter.PSPL_Solver_Hobson_Weighted.separate_modes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">separate_modes</span></code></a>()</p></td>
<td><p>Reads in the fits for the different modes (post_separate.dat) and splits it into a .dat file per mode.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.solve" title="model_fitter.PSPL_Solver_Hobson_Weighted.solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code></a>()</p></td>
<td><p>Run a MultiNest fit to find the optimal parameters (and their posteriors) given the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#model_fitter.PSPL_Solver_Hobson_Weighted.write_params_yaml" title="model_fitter.PSPL_Solver_Hobson_Weighted.write_params_yaml"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_params_yaml</span></code></a>()</p></td>
<td><p>Write a YAML file that contains the parameters to re-initialize this object, if desired.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Prior_copy</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>callback_plotter</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>check_data</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>dyn_log_likely</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>dyn_prior</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_best_fit_modes_model</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_model</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_modified_mag_err</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>log_likely_astrometry</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>log_likely_photometry</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>setup_params</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>summarize_results</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>summarize_results_modes</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>write_summary_maxL</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.log_likely">
<span class="sig-name descname"><span class="pre">log_likely</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.log_likely" title="Permalink to this definition"></a></dt>
<dd><p>Compute a log-likelihood where there is a hyperparameter,
alpha_k, that controls the weighting between each data k set. 
This algorithm is described in Hobson et al. 2002.</p>
<p>Specifically, we are implementing Eq. 35.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cube</strong><span class="classifier">list or dict</span></dt><dd><p>The dictionary or cube of the model parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.hobson_weight_log_likely">
<span class="sig-name descname"><span class="pre">hobson_weight_log_likely</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ln_prob_dk_giv_ak_1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.hobson_weight_log_likely" title="Permalink to this definition"></a></dt>
<dd><p>Implement a data-set-specific weighting scheme by using
a hyperparameter, alpha_k, for the kth data set as 
described in Hobson et al. 2002.</p>
<p>Specifically, we are implementing Eq. 16 and 23-27, with the
prior described in Eq. 21.</p>
<p>We are not using the simplifications in Section 5 for now.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.get_hobson_effective_weights">
<span class="sig-name descname"><span class="pre">get_hobson_effective_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.get_hobson_effective_weights" title="Permalink to this definition"></a></dt>
<dd><p>Return the effective weights, alpha_k, for each
data set. Photometry first, then astrometry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.LogLikelihood">
<span class="sig-name descname"><span class="pre">LogLikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.LogLikelihood" title="Permalink to this definition"></a></dt>
<dd><p>This is just a wrapper because PyMultinest requires passing in
the ndim and nparams.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.Prior_from_post">
<span class="sig-name descname"><span class="pre">Prior_from_post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nparams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.Prior_from_post" title="Permalink to this definition"></a></dt>
<dd><p>Get the bin midpoints</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.calc_best_fit">
<span class="sig-name descname"><span class="pre">calc_best_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.calc_best_fit" title="Permalink to this definition"></a></dt>
<dd><p>Returns best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If best-fit is median, then also return +/- 1 sigma
uncertainties.</p>
<p>If best-fit is MAP, then also need to indicate which row of
summary table to use. Default is <cite>s_idx = 0</cite> (global solution).
<cite>s_idx = 1, 2, … , n</cite> for the n different modes.</p>
<p><cite>tab = self.load_mnest_results()</cite>
<cite>smy = self.load_mnest_summary()</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.calc_chi2">
<span class="sig-name descname"><span class="pre">calc_chi2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.calc_chi2" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">str or dict, optional</span></dt><dd><p>model_params = ‘best’ will load up the best solution and calculate
the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.calc_chi2_manual">
<span class="sig-name descname"><span class="pre">calc_chi2_manual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.calc_chi2_manual" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">str or dict, optional</span></dt><dd><p>model_params = ‘best’ will load up the best solution and calculate
the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit">
<span class="sig-name descname"><span class="pre">get_best_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit" title="Permalink to this definition"></a></dt>
<dd><p>Returns best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If def_best is median, then also return +/- 1 sigma
uncertainties.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Either a dicitonary or a tuple of length=2 holding</dt><dd></dd>
<dt>two dictionaries, one for values and one for uncertainty ranges.</dt><dd></dd>
<dt>See calc_best_fit() for details.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit_model">
<span class="sig-name descname"><span class="pre">get_best_fit_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit_model" title="Permalink to this definition"></a></dt>
<dd><p>Identify best-fit model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>def_best</strong><span class="classifier">str</span></dt><dd><p>Choices are ‘map’ (maximum a posteriori), ‘median’, or
‘maxl’ (maximum likelihood)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit_modes">
<span class="sig-name descname"><span class="pre">get_best_fit_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.get_best_fit_modes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of best-fit parameters, where best-fit can be
median, maxl, or MAP. Default is maxl.</p>
<p>If def_best is median, then also return +/- 1 sigma
uncertainties.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Either a list of dicitonaries or a list where each entry is</dt><dd></dd>
<dt>a tuple of length=2 holding two dictionaries, one for values</dt><dd></dd>
<dt>and one for uncertainty ranges.</dt><dd></dd>
<dt>See calc_best_fit() for details.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_modes">
<span class="sig-name descname"><span class="pre">load_mnest_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_modes" title="Permalink to this definition"></a></dt>
<dd><p>Load up the separate modes results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_modes_results_for_dynesty">
<span class="sig-name descname"><span class="pre">load_mnest_modes_results_for_dynesty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_modes_results_for_dynesty" title="Permalink to this definition"></a></dt>
<dd><p>Make a Dynesty-style results object that can 
be used in the nicer plotting codes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_results">
<span class="sig-name descname"><span class="pre">load_mnest_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_results" title="Permalink to this definition"></a></dt>
<dd><p>Load up the MultiNest results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_results_for_dynesty">
<span class="sig-name descname"><span class="pre">load_mnest_results_for_dynesty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_results_for_dynesty" title="Permalink to this definition"></a></dt>
<dd><p>Make a Dynesty-style results object that can
be used in the nicer plotting codes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_summary">
<span class="sig-name descname"><span class="pre">load_mnest_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.load_mnest_summary" title="Permalink to this definition"></a></dt>
<dd><p>Load up the MultiNest results into an astropy table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.make_default_priors">
<span class="sig-name descname"><span class="pre">make_default_priors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.make_default_priors" title="Permalink to this definition"></a></dt>
<dd><p>Setup our prior distributions (i.e. random samplers). We will
draw from these in the Prior() function. We set them up in advance
because they depend on properties of the data. Also,
they can be over-written by custom priors as desired.</p>
<p>To make your own custom priors, use the make_gen() functions
with different limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.plot_dynesty_style">
<span class="sig-name descname"><span class="pre">plot_dynesty_style</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_vals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_vals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remake_fits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cornerplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kde</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.plot_dynesty_style" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sim_vals</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of simulated input or comparison values to 
overplot on posteriors.</p>
</dd>
<dt><strong>fit_vals</strong><span class="classifier">str</span></dt><dd><p>Choices are ‘map’ (maximum a posteriori), ‘mean’, or
‘maxl’ (maximum likelihood)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.plot_model_and_data">
<span class="sig-name descname"><span class="pre">plot_model_and_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mnest_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoomy_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_traces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.plot_model_and_data" title="Permalink to this definition"></a></dt>
<dd><p>Make and save the model and data plots.</p>
<p>zoomx, xoomy, zoomy_res : list the same length as <cite>self.n_phot_sets</cite>
Each entry of the list is a list <cite>[a, b]</cite> cooresponding to the plot limits</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.plot_model_and_data_modes">
<span class="sig-name descname"><span class="pre">plot_model_and_data_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">def_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.plot_model_and_data_modes" title="Permalink to this definition"></a></dt>
<dd><p>Plots photometry data, along with n random draws from the posterior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.print_likelihood">
<span class="sig-name descname"><span class="pre">print_likelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'best'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.print_likelihood" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_params</strong><span class="classifier">str or dict, optional</span></dt><dd><dl class="simple">
<dt>model_params = ‘best’ will load up the best solution and calculate</dt><dd><p>the chi^2 based on those values. Alternatively, pass in a dictionary
with the model parameters to use.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.sample_post">
<span class="sig-name descname"><span class="pre">sample_post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binmids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bininds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.sample_post" title="Permalink to this definition"></a></dt>
<dd><p>Randomly sample from a multinest posterior distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Nparams:</strong></dt><dd><p>number of parameters</p>
</dd>
<dt><strong>Nbins:</strong></dt><dd><p>number of histogram bins per dimension</p>
</dd>
<dt><strong>Nnzero:</strong></dt><dd><p>number of histogram bins with non-zero probability</p>
</dd>
<dt><strong>binmids</strong><span class="classifier">list of length N, each list entry is an array of shape (M, )</span></dt><dd><p>The centers of the bins for each parameter</p>
</dd>
<dt><strong>cdf</strong><span class="classifier">(Nnzero, ) array</span></dt><dd><p>CDF of the distribution. Only the non-zero probability entries.</p>
</dd>
<dt><strong>bininds</strong><span class="classifier">(Nnzero, Nparams) array</span></dt><dd><p>Histogram indices of the non-zero probability entries.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.separate_modes">
<span class="sig-name descname"><span class="pre">separate_modes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.separate_modes" title="Permalink to this definition"></a></dt>
<dd><p>Reads in the fits for the different modes (post_separate.dat)
and splits it into a .dat file per mode.</p>
<p>Is there a more intelligent way to deal with all the indices???
Write better later, but it seems to work for now…</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.solve" title="Permalink to this definition"></a></dt>
<dd><p>Run a MultiNest fit to find the optimal parameters (and their
posteriors) given the data.</p>
<p>Note we will ALWAYS tell multinest to be verbose.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="model_fitter.PSPL_Solver_Hobson_Weighted.write_params_yaml">
<span class="sig-name descname"><span class="pre">write_params_yaml</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#model_fitter.PSPL_Solver_Hobson_Weighted.write_params_yaml" title="Permalink to this definition"></a></dt>
<dd><p>Write a YAML file that contains the parameters to re-initialize
this object, if desired.</p>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="model_fitter.html" class="btn btn-neutral float-left" title="Model Fitter" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Prior_Generator.html" class="btn btn-neutral float-right" title="Prior Generators" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 Moving Universe Lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>